#include <cstdlib>
#include <iostream>
#include <unistd.h>
#include <vector>
#include <fstream>

using namespace std;

void bubble_sort(vector<long long> &nums);
void print_arr(vector<long long> &nums);
void sort_by_process(int n, vector<vector<long long>> &nums_seg);
void pipe_config(int& pid, int& pipe_id, int n, int &down[n][2], int &up[n][2]);
void merge_segments(vector< vector< long long > > &nums_seg);

int main(int argc, char *argv[])
{
    if (argc <= 1) {
        fprintf(stderr, "Fullname: Yangfei Li\nSEAS login: lyf\n");
        printf("Invalid input!\n");
        exit(1);
    }

    int n = 4;
    int thread_flag = 0;
    int lexicographic_flag = 0;
    int sharedMemory_flag = 0;

    int c;
    while ((c = getopt (argc, argv, "n:tLs")) != -1) {
        switch (c)
        {
            case 'n':
                n = atoi(optarg);
                if (n <= 0) {
                    fprintf(stderr, "Invalid number of processes.\n");
                    printf("Please enter a positive integer number of processes!\n");
                    exit(1);
                }
                break;
            case 't':
                if (sharedMemory_flag == 0) thread_flag = 1;
                break;
            case 'L':
                lexicographic_flag = 1;
                break;
            case 's':
                thread_flag = 0;
                sharedMemory_flag = 1;
                break;
            default:
                fprintf(stderr, "Undefined option!\n");
                printf("Undefined option!\n");
                exit(1);
        }
    }

    vector <long long> nums;
    for (int i = optind; i < argc; i++) {
        ifstream inFile(argv[i]);

        long long cur_num = 0;
        if (inFile.is_open()) {
            while (inFile >> cur_num) {
                nums.push_back(cur_num);
            }
            inFile.close();
        } else {
            fprintf(stderr, "Open file error!\n");
            printf("Can't open the file: %s\n", argv[i]);
            exit(1);
        }
    }

    switch (n)
    {
        case 1:
            printf("n = 1, sort directly!");
            bubble_sort(nums);
            print_arr(nums);
            return 0;
        default:
            printf("n > 1, sort by subprocess or ");
            vector<vector<long long>> nums_seg;

            auto size = nums.size() / n;
            auto counter = 0;
            while (counter < nums.size()) {
                vector<long long> seg;
                for (auto i = counter; i < nums.size(); ++i) {
                    seg.push_back(nums[i]);
                }
                nums_seg.push_back(seg);
                seg.clear();
                counter += size;
            }
            vector<long long> last_seg;
            for (auto i = counter - size; i < nums.size(); ++i) {
                last_seg.push_back(nums[i]);
            }
            last_seg.clear();

            switch (thread_flag)
            {
                case 1:
                    break;
                default:
                    sort_by_process(n, nums_seg);
                    merge_segments(nums_seg);
                    nums = nums_seg[0];
            }

            for (vector<long long> seg : nums_seg) {
                seg.clear();
            }
            nums_seg.clear();
    }

    nums.clear();
}

void swap(long long *a, long long *b) {
    long long temp = *a;
    *a = *b;
    *b = temp;
}

void bubble_sort(vector<long long> &nums) {
    for (long long i = 0; i < nums.size() - 1; i ++) {
        for (long long j = 0; j < nums.size() - i - 1; j ++) {
            if (nums[j] < nums[j + 1]) {
                swap(&nums[j], &nums[j + 1]);
            }
        }
    }
}

void print_arr(vector<long long> &nums) {
    for (long long i = 0; i < nums.size(); ++i) {
        printf("%lld\t%lld\n", i + 1, nums[i]);
    }
}

void sort_by_process(int n, vector<vector<long long>> &nums_seg) {
    int down[n][2];
    int up[n][2];
    int pid = NULL;
    int pipe_id = NULL;

    pipe_config(pid, pipe_id, n, down, up);

    printf("pid %d start work!", pid);


    // IPC in the down pipes;
    vector<long long> seg; // store the sorted numbers
    if (pid > 0) {
        /* parent  process */
        for (int i = 0; i < n; ++i) {
            FILE* parent_write_file = fdopen(down[i][1], "w");
            if (parent_write_file == NULL) {
                fprintf(stderr, "Parent write file fail!\n");
                printf("Parent write file fail!\n");
                exit(1);
            }

            for (long long num : nums_seg[i]) {
                fprintf(parent_write_file, "%lld\n", num);
            }

            fclose(parent_write_file);
            close(down[i][1]);
        }
    }
    else if (pid == 0)
    {
        /* child process */
        // child read from the down pipe and sort the array
        FILE* chile_read_file = fdopen(down[pipe_id][0], "r");
        if (chile_read_file == NULL) {
            fprintf(stderr, "Child read file fail!\n");
            printf("Child read file fail!\n");
            exit(1);
        }

        char buf[100];
        for(auto i = 0; i < nums_seg[pipe_id].size(); i++) {
            if (fgets(buf, sizeof(buf), chile_read_file) != NULL) {
                long long val = atoi(buf);
                printf("%lld", val);
                seg.push_back(val);
            }
        }

        fclose(chile_read_file);
        close(down[pipe_id][0]);
    }
    else
    {
        fprintf(stderr, "Fork error!");
        printf("Fork error after pipe config!");
        exit(1);
    }

    // IPC in the up pipes;
    if (pid > 0) {
        /* parent  process */
        for (auto i = 0; i < n; ++i) {
            FILE* parent_read_file = fdopen(up[i][0], "r");
            if (parent_read_file == NULL) {
                fprintf(stderr, "Parent read file fail!\n");
                printf("Parent read file fail!\n");
                exit(1);
            }

            char buf[100];
            for (long long &num : nums_seg[i]) {
                if (fgets(buf, sizeof(buf), parent_read_file) != NULL) {
                    long long val = atoi(buf);
                    printf("%lld", val);
                    num = val;
                }
            }

            fclose(parent_read_file);
            close(up[i][0]);
        }
    }
    else if (pid == 0)
    {
        /* child process */
        // child read from the down pipe and sort the array
        if (seg.size() > 0) {
            bubble_sort(seg);
            FILE* child_write_file = fdopen(up[pipe_id][1], "w");
            if (child_write_file == NULL) {
                fprintf(stderr, "Child write file fail!\n");
                printf("Child write file fail!\n");
                exit(1);
            }

            for (long long num : seg) {
                fprintf(child_write_file, "%lld\n", num);
            }

            fclose(child_write_file);
            close(up[pipe_id][1]);
        } else {
            fprintf(stderr, "No data read from pipe! (sort by process)\n");
            printf("No data read from pipe! (sort by process)\n");
            exit(1);
        }
    }
    else
    {
        fprintf(stderr, "Fork error!");
        printf("Fork error after pipe config!");
        exit(1);
    }

    seg.clear();
    exit(0);
}

void pipe_config(int& pid, int& pipe_id, int n, int &down[n][2], int &up[n][2]) {
    for (int i = 0; i < n; ++ i) {
        pipe_id = i;
        pipe(up[i]);
        pipe(down[i]);
        pid = fork();

        if (pid > 0) {
            /* parent  process */
            close(down[i][0]);
            close(up[i][1]);
        } else if (pid == 0) {
            /* child process */
            close(down[i][1]);
            close(up[i][0]);
        } else {
            fprintf(stderr, "Fork error!");
            printf("Fork error!");
            exit(1);
        }
    }
}

vector<long long> merge(vector<long long> left, vector<long long> right) {
    vector<long long> merged_array;
    auto i = 0, j = 0;
    while (i < left.size() && j < right.size()) {
        if (left[i] < right[i]) {
            merged_array.push_back(left[i]);
            i ++;
        } else {
            merged_array.push_back(right[j]);
            j ++;
        }
    }
    if (i < left.size()) {
        merged_array.push_back(left[i]);
        i ++;
    }
    if (j < right.size()) {
        merged_array.push_back(right[i]);
        j ++;
    }
    return merged_array;
}
//
//vector<long long> merge_helper(vector<vector<long long>> &nums_seg, unsigned long start, unsigned long end) {
//    if (start == end) return nums_seg[end];
//
//    auto mid = start + (end - start) / 2;
//    vector<long long> left = merge_helper(nums_seg, start, mid);
//    vector<long long> right = merge_helper(nums_seg, mid + 1, end);
//
//    return merge(left, right);
//}

void merge_segments(vector<vector<long long>> &nums_seg) {
    while(nums_seg.size() > 1) {
        nums_seg.push_back(merge(nums_seg[0], nums_seg[1]));
        nums_seg.erase(nums_seg.begin());
        nums_seg.erase(nums_seg.begin());
    }
}